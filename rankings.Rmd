---
title: "![](g1397.svg) Rankings"
output:
  html_document:
    includes:
        in_header: "favicon.html"
    code_folding: hide
    theme: paper
---

***

```{r echo=FALSE, message=FALSE}
# Import datafile with scraped content
load("espnPull.Rdata")

# Dependencies
library(rmarkdown)
library(viridis)
library(knitr)
library(kableExtra)
library(formattable)
library(elo)
library(tidyverse)
library(DT)

knitr::opts_chunk$set(comment = "", message = FALSE, warning = FALSE)

```
### {.tabset .tabset-fade}

#### Power Rankings

Here are your upgraded team standings. Going beyond the typical win-loss outcomes, we are employing the ELO metric to achieve a statistically derived power ranking. With this we are taking into consideration head-to-head matchup outcomes and margin of victory to determine team strength.

Because this metric looks at past results to determine ranking, we do need to wait till a few weeks into the season to start seeing more accurate numbers. If you're interested in some further reading, click [here](https://en.wikipedia.org/wiki/Elo_rating_system).

* ELO: statistical power ranking (higher better)
* D: Delta for ELO, change in power ranking score
* SoS: strength of schedule (higher harder)
* S: Current win streak
* ACQ: number of player acquisitions

```{r}
teamCount <- length(standings$name)

# SoS Calculation
# Rank values by points against within week
ptsAgainstRanked <- results %>%
    group_by(week) %>%
    mutate(SoS = order(order(pointsAgainst, decreasing = F)))
# Subset for all current values
ptsAgainstRanked <- subset(ptsAgainstRanked, ptsAgainstRanked$pointsAgainst > 0)
# Average opposed ranks by team
finalSos <- aggregate(SoS ~ name, data = ptsAgainstRanked, mean)

# ELO calculation
## Method sans mov
eloOutput1 <- elo.run(score(homePoints, awayPoints) ~ homeTeam + awayTeam, data = boxScore, k = 30)

## MOV method
eloOutput <- elo.run(mov(homePoints, awayPoints) ~ homeTeam + awayTeam, data = boxScore, k = 1)
eloRating <- data.frame(as.data.frame(eloOutput$teams), as.data.frame(final.elos(eloOutput)))
eloRating$final.elos.eloOutput. <- round(eloRating$final.elos.eloOutput., digits = 0)
#rownames(eloRating) <- c(1:teamCount)

# ELO delta
lastWeekNum <- str_pad(as.character(max(as.numeric(boxScore$week))), 2, pad = "0")
lastWeek <- subset(boxScore, week != lastWeekNum)
# lastWeek <- boxScore[-c((nrow(lastWeek)-(teamCount/2 - 1)):nrow(lastWeek)), ]
lastElo <- elo.run(mov(homePoints, awayPoints) ~ homeTeam + awayTeam, data = lastWeek, k = 1)
lastEloRating <- data.frame(as.data.frame(lastElo$teams), as.data.frame(final.elos(lastElo)))
lastEloRating$final.elos.lastElo. <- round(lastEloRating$final.elos.lastElo., digits = 0)
# Delta calculation
eloDelta <- eloRating$final.elos.eloOutput. - lastEloRating$final.elos.lastElo.

# Generate power ranking table by merging ELO, SoS, and standing
standingsTable <- merge(eloRating, standings[, c("logo", "name", "lastName", "wins", "losses", "percentage", "pointsFor", "pointsAgainst", "streakLength", "streakType", "acq", "dues")], by.x = "eloOutput.teams", by.y = "name")
standingsTable$streakLength <- ifelse(standingsTable$streakType %in% ("LOSS"), standingsTable$streakLength * -1, standingsTable$streakLength)
standingsTable <- merge(standingsTable, finalSos, by.x = "eloOutput.teams", by.y = "name")
standingsTable <- data.frame(x = standingsTable$logo,
                             Team = standingsTable$eloOutput.teams,
                             NAME = standingsTable$lastName,
                             ELO = standingsTable$final.elos.eloOutput.,
                             D = eloDelta,
                             SoS = standingsTable$SoS,
                             W = standingsTable$wins,
                             L = standingsTable$losses,
                             PCT = standingsTable$percentage,
                             S = standingsTable$streakLength,
                             PTS4 = standingsTable$pointsFor,
                             PTSA = standingsTable$pointsAgainst,
                             ACQ = standingsTable$acq)
standingsTable <- standingsTable[order(-standingsTable$ELO),]
rownames(standingsTable) <- c(1:teamCount)
standingsTable$SoS <- round(standingsTable$SoS, digits = 2)
standingsTable$PCT <- round(standingsTable$PCT, digits = 2)

# Generate html formatted table of power rankings
DT::datatable(standingsTable, options = list(pageLength = teamCount, dom = 'tip', paging = FALSE), style = "bootstrap", escape = FALSE) %>%
    formatStyle('SoS',
                background = styleColorBar(standingsTable$SoS, 'lightblue'),
                backgroundSize = '100% 90%',
                backgroundRepeat = 'no-repeat',
                backgroundPosition = 'center') %>%
    formatStyle('ACQ',
                background = styleColorBar(standingsTable$ACQ, 'lightblue'),
                backgroundSize = '100% 90%',
                backgroundRepeat = 'no-repeat',
                backgroundPosition = 'center') %>%
    formatStyle('D',
                color = styleInterval(0, c('red', 'green')),
                fontWeight = 'bold') %>%
    formatStyle('S',
                color = styleInterval(0, c('red', 'green')),
                fontWeight = 'bold')
#    formatStyle('DUES',
#                backgroundColor = styleEqual(unique(standingsTable$DUES),
#                                             c('lightgreen', 'lightpink')))
```

#### Predictions

These are your ELO-based predictions for this week's matchups. Since ELO is a predictive metric, current scores can be used as a basis to predict future performance. Teams with a higher ELO should typically beat teams with a lower ELO. This approach closely follows that of [FiveThirtyEight](https://projects.fivethirtyeight.com/2019-nfl-predictions/games/).

* PoW = Probability of Win

```{r}
# Assemble data structure for current week matchups
weeksMatchups <- subset(boxScoreFull, week == str_pad(totalJSON$scoringPeriodId, 2, pad = "0"))
weeksMatchups <- data.frame(homeTeam = weeksMatchups$homeTeam, awayTeam = weeksMatchups$awayTeam)
weeksMatchups <- merge(weeksMatchups, standings[,c("name", "kableLogo")], by.x = "homeTeam", by.y = "name", all.x = T)
weeksMatchups <- merge(weeksMatchups, standings[,c("name", "kableLogo")], by.x = "awayTeam", by.y = "name")
weeksMatchups1 <- data.frame(homeTeam = weeksMatchups$awayTeam, awayTeam = weeksMatchups$homeTeam)

# Make ELO based matchup outcome predictions
matchupPredictions <- data.frame(
                                 x = weeksMatchups$kableLogo.x,
                                 HomeTeam = weeksMatchups$homeTeam,
                                 PoW = percent(predict(eloOutput, newdata = weeksMatchups[1:2])),
                                 xx = weeksMatchups$kableLogo.y,
                                 AwayTeam = weeksMatchups$awayTeam,
                                 PoW. = percent(predict(eloOutput, newdata = weeksMatchups1[1:2])))

# Create kable table of matchup predictions
matchupPredictions %>%
  mutate(PoW = color_tile(
    "lightblue", "lightpink")(PoW),
  ) %>%
  mutate(PoW. = color_tile(
    #AwayPoW, color = "white", bold = T,
    #background = spec_color(AwayPoW, option = "viridis", direction = -1),
    "lightblue", "lightpink")(PoW.),
  ) %>%
  kable(escape = F) %>%
  kable_styling(c("striped"), font_size = 20, full_width = F)

# Save workspace image to pass data
save.image(file = "standings.Rdata")
```


